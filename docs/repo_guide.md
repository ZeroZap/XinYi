# XinYi 仓库阅读分析与代码指导（Repo Guide）

> 本文用于沉淀对 **XinYi** 仓库的阅读分析与工程约定，作为后续贡献代码、Review、重构与新增模块的统一指导文档。
>
> 适用范围：本仓库所有 `C`/`CMake`/`Makefile`/脚本/Kconfig 相关改动。

---

## 1. 仓库定位与目标

### 1.1 XinYi 是什么
XinYi 是一个 **模块化嵌入式 C 框架**（以 C99 为基准），面向资源受限 MCU/SoC 系统，目标是提供一套可移植的“组件化能力栈”，覆盖：

- 硬件抽象（HAL）
- RTOS 抽象（OSAL）
- 通信协议（如 MQTT/Modbus/AT/ISO7816 等）
- 加密与校验（AES/HMAC/RNG/CRC/Base64/MD5 等）
- 数据管理（EEPROM/NOR Flash/TLV/NVM 等）
- 工具与通用库（自定义 C 库、状态机、日志系统等）

### 1.2 你在仓库里写代码的基本原则
- **组件化**：功能以组件为单位组织，尽量避免“跨组件私用内部实现”。
- **可裁剪**：通过 Kconfig/编译宏/构建系统实现按需启用，避免强依赖。
- **可移植**：平台相关实现与平台无关接口解耦（尤其是 HAL/OSAL）。
- **可测试**：优先提供最小可运行用例与单元测试（如仓库含 `UniTest/`）。
- **可维护**：统一编码风格、日志、错误码、命名、目录结构与文档。

---

## 2. 仓库结构（基于当前可见根目录）

> 说明：我基于仓库根目录可见内容总结。若后续目录结构调整，请同步更新本文。

当前根目录关键项（非穷举）：
- `components/`：核心组件集合（协议、加密、OSAL、日志、数据管理等通常在此）
- `projects/`：具体工程/示例/板级项目（用于集成与产物构建的入口通常在此）
- `utils/`：脚本与工具（格式化、构建辅助等）
- `docs/`：文档
- `UniTest/`：测试相关
- `CMakeLists.txt` / `Makefile`：顶层构建入口
- `Kconfig`：配置入口
- `xy_config.h`：配置头文件（通常用于编译期开关/默认配置）
- `xy_code_style.md`：编码规范
- `RULEBOOK.md`：开发/生成/贡献规则（高优先级遵循）
- `.clang-format`：格式化配置

### 2.1 文档与真实结构不一致时怎么办
如果你发现 `ReadMe.md` 中描述的目录（例如某些 `bsp/` 或 `xy_hal/` 路径）与实际代码目录不一致：

1. **以代码为准**：先确认实际路径与 include 引用关系。
2. **补全文档**：在 `docs/` 或对应组件的 README 里写清楚差异原因（历史遗留/重构中/迁移未完成等）。
3. **避免破坏性重命名**：除非你能同时更新构建系统、include 路径、示例项目与 CI。

---

## 3. 构建系统与配置体系（统一约定）

### 3.1 构建系统总览
仓库同时存在：
- 顶层 `Makefile`
- 顶层 `CMakeLists.txt`
- `Kconfig` 配置体系
- `build.sh` / `build.bat` 这类跨平台脚本（用于统一调用）

**约定**：
- 新增组件时，优先做到 **Make + CMake 双通路可构建**（除非仓库明确放弃其中之一）。
- 组件需要具备“可单独编译”的能力（便于定位问题与复用）。
- 配置开关统一沉淀在 Kconfig / `xy_config.h`（避免散落的宏定义）。

### 3.2 Kconfig/配置头的使用边界
- **Kconfig**：用于“功能启用/禁用”、“组件裁剪”、“默认值选择”等。
- **`xy_config.h`/`*_cfg.h`**：用于编译期常量配置（缓冲区大小、超时、启用某算法等）。

**禁止**：
- 在业务代码里到处 `#define` 功能开关（应集中在配置体系）。
- 用宏开关绕开依赖关系（例如启用某协议却没有明确依赖其传输层/OSAL）。

---

## 4. 编码规范（强制遵循）

### 4.1 规范来源与优先级
你必须遵循：
1. `RULEBOOK.md`
2. `xy_code_style.md`
3. `.clang-format`

若出现冲突：
- 优先遵循 `RULEBOOK.md`
- 然后是 `xy_code_style.md`
- 最后是 `.clang-format` 的自动格式化结果

### 4.2 语言与风格约定（C99）
- 使用 C99（避免编译器私货语法）
- 4 空格缩进，不使用 Tab
- 命名：`lowercase_with_underscores`
- 公共 API 必须写 Doxygen 注释（头文件对外可见的函数/类型）

### 4.3 日志系统：必须使用 `xy_log_*`
- 你应该使用 `xy_log_d()/i()/w()/e()`，不要直接 `printf()`。
- 组件内允许定义 `LOCAL_LOG_LEVEL` 控制输出粒度。
- 日志内容要可追踪、可定位：包含关键参数、返回码、状态机状态等。

---

## 5. 组件设计与依赖管理

### 5.1 组件的最小交付单元（建议）
一个“合格组件”建议包含：
- `README.md`：说明用途、API、配置、示例
- `include/` 或 `inc/`：对外头文件（只暴露稳定 API）
- `src/`：实现
- `*_cfg.h`：配置头（如需要）
- `Kconfig`：裁剪开关（如需要）
- `CMakeLists.txt` / `Makefile`：可构建
- `tests/` 或接入 `UniTest/`：可验证

### 5.2 依赖方向（推荐）
- `components/*` 可以依赖 `utils/*`（工具库、通用方法）
- `components/*` 可以依赖 `osal`（抽象层）
- **尽量避免** 组件之间互相环形依赖；如果无法避免：
  - 抽象出公共接口到更底层的 `utils` 或 `common` 组件
  - 或通过接口回调/适配层解耦

### 5.3 API 边界与可替换性
- 对外 API：尽量稳定、参数明确、返回值可判定
- 对内实现：可替换、可移植（例如平台相关实现放在单独目录）
- 避免把“平台寄存器操作”混进“协议解析”代码

---

## 6. 错误码、返回值与健壮性

### 6.1 返回值约定（建议统一）
- 约定统一的 `xy_err_t` 或类似返回类型（如果仓库已有，则必须沿用）。
- 成功返回 `0` 或 `XY_OK`，失败返回负值或枚举错误码（与现有约定对齐）。

### 6.2 参数检查
- 公共 API 必须做参数校验（指针 NULL、长度、范围、状态等）
- 对“可恢复错误”返回明确错误码
- 对“不可恢复错误”输出错误日志，必要时触发断言（与 OSAL/项目策略一致）

---

## 7. 文档规范（你应该怎么写）

### 7.1 文档放哪里
- 仓库级指导：`docs/`（本文即仓库级）
- 组件级说明：组件目录内 `README.md`
- 专题说明：`docs/*.md`（例如 CRC/RTC 等）

### 7.2 文档应包含什么
- 目的/适用场景
- 依赖项（OSAL/HAL/第三方库）
- 配置项（Kconfig/`*_cfg.h`）
- 初始化流程与调用示例
- 常见错误与排查方式（含日志关键字）

---

## 8. 提交流程与 Review 清单

### 8.1 提交前必须做的事
- 运行格式化（clang-format 或脚本）
- 构建通过（Make/CMake 至少一种主通路）
- 若涉及行为变更：补/改测试或示例
- 更新文档（组件 README / docs）

### 8.2 Review Checklist（建议在 PR 描述里逐项自检）
- [ ] 是否遵循 `xy_code_style.md` 与 `RULEBOOK.md`
- [ ] 是否引入了不必要的跨组件依赖
- [ ] 是否所有公共 API 有 Doxygen 注释
- [ ] 是否使用 `xy_log_*`（无 `printf` 泄露）
- [ ] 是否考虑了裁剪（Kconfig/宏开关）
- [ ] 是否考虑了线程安全/ISR 场景（如涉及 OSAL/HAL）
- [ ] 是否有清晰错误码与日志定位信息
- [ ] 是否补充 README/配置项说明

---

## 9. 你可以如何快速上手（建议路径）

### 9.1 第一步：读规则与风格
- `RULEBOOK.md`
- `xy_code_style.md`
- `.clang-format`（理解自动格式化会怎么改你的代码）

### 9.2 第二步：选择一个组件做“端到端阅读”
从 `components/` 内挑一个你要改动的模块：
- 先读该组件的 README（若没有就补一个）
- 再看对外头文件（API 面）
- 再看实现（状态机/协议解析/驱动调用）
- 最后看它如何被 `projects/` 集成与配置裁剪

### 9.3 第三步：建立“依赖图”习惯
每次新增依赖前，问自己：
- 这个依赖是否可裁剪？
- 是否会导致循环依赖？
- 是否应该通过接口/回调倒置依赖？

---

## 10. 后续维护建议（本文如何迭代）
建议你在以下事件发生时更新本文：
- 新增/重构了顶层目录结构
- 构建系统策略变化（只保留 CMake 或 Make 等）
- 引入新的编码规范/静态检查工具
- 引入新的核心组件（例如新的网络栈/加密库/存储层）

---

## 附：与仓库 `ReadMe.md` 的关系
`ReadMe.md` 用于对外介绍与快速开始；本文 `docs/repo_guide.md` 用于**对内指导工程实现与贡献行为**。

若两者内容冲突：
- 以代码现状为准；
- 并尽快同步修正 `ReadMe.md` 与本文的一致性。
